\section{Desarrollo}

\subsection{Programa}

El programa que hicimos permite aplicar ciertos operadores de derivación a una imagen especificada por línea de comandos. Los operadores implementados son Roberts, Prewitt y Sobel. El primero tiene matrices de 2x2 y detecta bordes en diagonal. Los otros dos tienen matrices de 3x3 y detectan bordes verticales u horizontales.


%
%acá pondría las matrices de Roberts, Prewitt y Sobel
%


Para cada operador solicitado, aplica la matriz correspondiente en X, luego en Y, y finalmente suma los resultados. Para el caso de Sobel, permite aplicar convolución en una única dirección (X o Y).

%resaltar cvLoadImage y OpenCV
La imagen de entrada puede tener cualquier formato que la función cvLoadImage de OpenCV soporte; todos los formatos comunes están incluidos. Por cada operador utilizado se guarda una nueva imagen en escala de grises (con un sufijo en el nombre que indica el operador y la misma extensión y tamaño que la imagen de entrada) que grafica los bordes detectados.

Por último, el programa muestra por salida estádar la cantidad aproximada de clocks utilizada para la ejecución del algoritmo.

%poner OpenCV y cvSobel en cursiva o algo así
Las implementaciones están hechas en lenguaje ensamblador, aunque el programa también permite usar la implementación del operador Sobel de la biblioteca OpenCV (función cvSobel), así como también grabar la versión en escala de grises de la imagen de entrada. Por último, realiza también detección de bordes usando una primera implementación del operador de Sobel que hicimos en C para ayudarnos a desarrollar el algoritmo y probar variantes.

Para cada punto de la imagen fuente el programa aplica la matriz correspondiente en X, satura el valor a 0 y 255, luego aplica la matriz en Y, satura también su resultado, y finalmente suma ambos coeficientes y satura la suma. Ese valor es grabado en la imagen generada.

Además de la función cvSobel Usamos OpenCV para cargar y guardar imágenes en archivos y transformar imágenes a escala de grises.


\subsection{Algoritmos}
Si bien se trata de procedimientos bastante sencillos e intuitivos, hubo varios aspectos en los que surgieron dudas, problemas o diversidad de posibilidades.

En un píxel en donde la intensidad de la imagen crece hacia la derecha, diremos que se trata de un borde "hacia la derecha". Si en ese punto la imagen en cambio oscurece hacia la derecha, diremos que es un borde "hacia la izquierda".

Notar que, en el caso de Prewitt o Sobel, la matriz de convolución en X (que detecta bordes verticales) arroja un resultado positivo en los bordes hacia la derecha y negativo en los bordes hacia la izquierda. Asimismo la matriz de convolución en Y (que detecta bordes horizontales) produce números positivos en bordes hacia abajo y negativos en bordes hacia arriba. Con las matrices de Roberts pasa lo mismo, salvo que los bordes son positivos hacia el noroeste para la matriz X o hacia el noreste para la Y, y negativos hacia el sudeste o sudoeste respectivamente.

%destacar dx, dy
Hay muchas formas de tratar los valores númerico de la derivación en X y en Y de cada píxel para graficarlos. Con la implementación que hicimos en C de Sobel probamos varias de ellas. Llamaremos dx y dy a los valores obtenidos aplicando derivación en X y en Y.

Una opción es graficar un punto cuya intensidad refleje el módulo del vector (dx, dy). De esta manera se obtiene una imagen oscura con los puntos borde más claros. La imagen muestra los bordes en todas las direcciones, aunque no permite distinguir en qué sentido van. Es decir, un borde hacia la derecha se grafica igual que uno hacia la izquierda. Para el cálculo del módulo puede usarse la norma 2 o bien la norma 1, bastante más rápida de computar.

Otra transformación típica es saturar los valores a un mínimo y a un máximo, lo que permite visualizar los bordes a grandes rasgos sin importar todos los matices de variación. Por ejemplo se los puede saturar a 0 y a 255. Hay que notar que haciendo esto se desprecian todos los bordes negativos, por lo tanto sólo se grafican los bordes que van en un sentido. Si en cambio se suma 128 al valor antes de saturarlo, se puede generar una imagen en la que predomina el gris y donde los bordes positivos se muestran como zonas claras y los bordes negativos como zonas oscuras.

Las variantes que implementamos nosotros son las siguientes:
%esto es una lista
    1) norma 1 de (dx, dy) saturada a 255
    2) dx + dy + 128 saturado a 0 y a 255
    3) saturación de dx y dy a 0 y 255, suma, y saturación de la suma a 255

La idea inicial que teníamos, sugerida en la consigna del trabajo, era implementar la variante 1, que grafica bordes en cualquier dirección. Finalmente, sin embargo, decidimos usar la tercera variante, ya que sus resultados coinciden con los arrojados por la implementación de Sobel de OpenCV, contra la cual deseábamos comparar performance. Esto quiere decir que las imágenes generadas por nuestro programa son oscuras con zonas claras donde la imagen original tiene aumentos de intensidad hacia abajo o hacia la derecha (hacia el noroeste o hacia el noreste en el caso de Roberts). Los bordes que van en sentido contrario no se reflejan de ninguna manera así que es imposible saber dónde están o cuán abruptos son.

La variante 2 produce gráficos diferentes e interesantes de observar. Se pueden ver bordes en ambos sentidos, graficados de manera distinta. Los bordes positivos en blanco y los negativos en negro. Sin embargo no muestra bordes en todas las direcciones. De hecho, el efecto de sumar la derivada en X con la de Y es que los bordes se grafican en una única dirección (una diagonal). Los bordes perpendiculares a esta diagonal hacen que dx se anule con dy y por lo tanto no se visualizan.

En el momento que optamos sumar las derivadas en X y en Y porque la técnica usada por OpenCV parecía ser esa, surgió una idea: en lugar de aplicar la matriz de X, luego la de Y y sumar los resultados, sería más eficiente (y más sencillo de implementar) hacer una sola pasada usando la matriz suma de las dos matrices. Esto razonamiento es, además de intuitivo, matemáticamente correcto.

Sin embargo las imágenes generadas aún no eran iguales a las de OpenCV. Algunos bordes, pese a ser "positivos", estaban ocultos. Lo que sucede es que por ejemplo una derivada positiva en X se puede anular con una derivada negativa en Y. Esto hace que se vean casi exclusivamente los bordes que apuntan en dirección sudeste.

Finalmente se concluyó que la técnica correcta (para generar dibujos como los de OpenCV) era saturar cada derivada parcial a 0 y a 255 y recién después sumarlas. Como la primera saturación elimina negativos, es imposible que las derivadas se cancelen, y se visualizan todos bordes que apuntan hacia abajo y/o hacia la derecha.


\subsection{Implementación}

%%algo sobre el bug de unsigned char

%%algo sobre los bugs de assembler

%%algo sobre push/pop vs. registros


