\section{Desarrollo}

\subsection{Programa}

El programa que hicimos permite aplicar ciertos operadores de derivación a una imagen especificada por línea de comandos. Los operadores implementados son Roberts, Prewitt,  Sobel y Frei-Chen. El primero tiene matrices de 2x2 y detecta bordes en diagonal. Los otros tres tienen matrices de 3x3 y detectan bordes verticales u horizontales. Se pueden invocar tanto las versiones de propósito general para los primeros tres, como las versiones de los operadores que utilizan instrucciones SIMD. 

Para cada operador solicitado el programa aplica la matriz correspondiente en X, luego en Y, y finalmente suma los resultados. Para el caso de Sobel, también permite aplicar convolución solamente en X o solamente en Y.

Utilizamos la biblioteca \textbf{OpenCV} para manejar las imágenes convenientemente, es decir, dejamos la carga, el guardado de imágenes y el ``aplanado'' a escala de grises a dicha biblioteca. El grupo se limitó a crear una interfaz que contenga lo mencionado y a implementar los algoritmos de los operadores de detección de bordes en lenguaje ensamblador. 




%%%%%%%%%%%%%%%%%%%
% Acá en vez de contar todo el chamuyo de como se deriva si de derecha a izquierda o si es mejor 
% saturar de una forma u otra, creo que sería más productivo y fructífero mencionar los detalles de implementación
% de los operadores ya que son todos distintos y ya que la magia está en utilizar bien simd para los distintos casos
% but feel free to edit me - JM.
%%%%%%%%%%%%%%%%%%%%%

\subsection{Implementación}

%esto serían observaciones generales
% Respecto del procesamiento de datos en paralelo via-SIMD lo que se hizo fue procesar los pixeles de las imágenes de la siguiente forma. Por un lado sabemos que la imagen tiene un ancho múltiplo de 16 pixeles lo cual facilita el \emph{fetch} de los mismos a los registros \texttt{xmm}. Además tenemos en cuenta que la imagen es de 8 bits en escala de grises, es decir, cada pixel es un número de 1 byte que según la intensidad oscila en valores enteros entre 0 y 255. 
% 
% Cada registro \texttt{xmm} tiene 128 bits de ancho, o lo que es igual, 16 bytes. Como el ancho de la imagen tiene las características mencionadas anteriormente, esto nos permite visualizar a la imagen en algo de $n$ columnas de 16 bytes de ancho, justamente el ancho de los registros y $n$ es un número entero cosa que nos permite en $n$ viajes a memoria cargar toda una fila en los registros y poder operar con ella convenientemente.
% 
% Esto es muy interesante porque antes se hacían $k$ accesos a memoria (donde $k$ es el ancho en pixeles de la imagen). Ahora se traen en ráfaga $\frac{k}{16}$ pixeles (si la imagen está en escala de grises). Esto minimiza notablemente la penalización que se paga por acceder a la memoria RAM que como sabemos es mucho más lenta en términos de velocidad que los registros internos del procesador.
% 
% Estas observaciones valen en caso que la operatoria se haga con valores enteros. Para el caso de Frei-Chen que tiene un $\sqrt{2}$ en la matriz esto deja de ser cierto ya que en ese caso, se opera directamente con números reales representados con precisión simple de 32-bits.

\subsubsection{Precisión numérica} %%esto creo que es general, de última yo lo uso en roberts y lo pongo ahí sino.

Respecto de la forma de operar aritméticamente, surge un inconveniente si tenemos 16 pixeles (almacenados como bytes) cuando tenemos que hacer una resta por ejemplo, ya que podríamos estar perdiendo información al saturar. Por ejemplo:

\begin{center}
\begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}  \\
\end{pmatrix}$
\end{minipage}
\ \ 
 \begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
15 & 255 \\
1 & -255 \\
\end{pmatrix}$
\end{minipage}
\end{center}

En este caso si la convolución se hace al $a_{11}$ con la matriz de Roberts quedaría: $a_{11} = a_{22} - a_{21}$ que en nuesto caso se resume a...

Entonces para que en las restas de números no se pierda información en el medio lo que se hace es lo siguiente: traemos los bytes pero luego los desempaquetamos como \emph{words} de forma tal de no perder información con las restas. Luego los empaquetamos saturados para grabarlos en la imagen destino convenientemente. 

\pagebreak
Gráficamente sería algo como: 

\includegraphics[scale=0.55]{/home/connor/Escritorio/fetch.pdf}

Sin embargo, estas observaciones valen en caso que la operatoria se haga con valores enteros. Para el caso de Frei-Chen que tiene un $\sqrt{2}$ en la matriz esto deja de ser cierto ya que en ese caso, se opera directamente con números reales representados con precisión simple de 32-bits.

\subsubsection{Operador de Roberts}

El operador de Roberts presenta las siguientes matrices de convolución para $x$ e $y$ respectivamente.



\begin{center}
\begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
1 & 0 \\
0 & -1  \\
\end{pmatrix}$
\end{minipage}
\ \ 
 \begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
0 & 1 \\
-1 & 0 \\
\end{pmatrix}$
\end{minipage}
\end{center}

Dada la precondición que dice que el ancho de las imágenes es múltiplo de 16 bytes y que cada pixel está representado con 1 byte, entonces, podemos visualizar a la imagen de forma tal que esta tiene $n$ columnas de 16 bytes de ancho. Además al usar los registros \texttt{xmm} de 16 bytes de tamaño, podemos efectivamente para una fila de tamaño $k$ pixeles hacer nada más que $\frac{k}{16}$ accesos a memoria para traer toda la fila en cuestión cuando antes no quedaba otra opción que traer todos los pixeles de uno en uno. 

El algoritmo que se encarga de realizar el operador de Roberts está dividido en dos partes independientemente de la dirección en la que se está pasando el operador. 

En primer lugar, como el ancho de la imagen es múltiplo de 16 bytes, se optó por dividir dicho ancho en múltiplos de 16 bytes, que como se mencionó antes es el tamaño de los registros \texttt{xmm}. Entonces se tienen por lo menos $n$ columnas de 16 bytes de ancho y se procede trabajar con las $n-1$ primeras de la siguiente forma: 
\begin{itemize}
\item Máscara X: Se cargan los 16 bytes de la fila actual en un registro y luego se cargan los 16 bytes de la fila siguiente pero desplazados uno. Es decir, si la fila actual es $x$ y la siguiente es $x'$ entonces se carga en un registro el $x_i, x_{i+1}, x_{i+2}, ... , x_{i+15}$ y en el otro $x'_{i+1}, x'_{i+2}, x'_{i+3}, ... , x'_{i+16}$ donde $i$ es el número de la columna de la imagen. 
\item Máscara Y: Este caso es análogo al anterior solo que el desplazamiento se hace en la fila actual, osea, se carga el $x_{i+1}, ..., x_{i+16}$ en un registro y en el siguiente el $x'_i, ... x'_{i+15}$
\end{itemize}

En ambos casos la idea del algoritmo es mantener las cosas lo más simple posible, de forma tal de que en este punto lo único que se hace es restar cada uno de los 16 bytes (que están separados en grupos de 8 words) y luego reempaquetarlos y dejarlos en la imagen destino. 

Luego se procesa la última columna de la siguiente manera:
\begin{itemize}
\item Mascara X: Se carga la fila actual y la siguiente sin desplazamiento pero a la fila siguiente se la \emph{shiftea} a izquierda un byte de forma tal de tener en un registro $x_i, x_{i+1}, x_{i+2}, ... , x_{i+15}$ para la fila actual y en otro para la siguiente: $x'_{i+1}, x'_{i+2}, x'_{i+3}, ..., x'_{i+15}, 0$. De esta manera logramos cargar la fila como corresponde (sin pasarnos del límite que tenemos que tener) y operarla correctamente luego de desplazarla dentro del registro. 
\item Máscara Y: Este caso es prácticamente igual al anterior. Se cargan sin desplazamiento tanto la fila actual como la siguiente. Luego se desplaza dentro del registro la fila actual con un \emph{shift} y se pone un 0 en la última columna de la fila siguiente de forma tal de dejar el borde en 0 mediante una máscara de bits dado que ese último pixel no es procesable.
\end{itemize}

En ambos casos se realizan las operaciones aritméticas pertinentes y luego se guarda el resultado donde corresponde. 

El volcado de datos a memoria se realiza solamente cuando ambas máscaras han sido pasadas. Antes se utiliza un registro \texttt{xmm} como acumulador para evitar un acceso que sería innecesario.



%acá se pueden poner imágenes... opcional igual. En caso negativo explico un poco mejor sino se entiende...

%\includegraphics[scale=0.60]{/home/connor/Escritorio/dibujo.pdf}



\subsubsection{Operador de Prewitt}

Matrices de convolución para el operador de Prewitt en $x$ e $y$ respectivamente.

\begin{center}
\begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
-1 & 0 & 1 \\
-1 & 0 & 1 \\
-1 & 0 & 1 \\
\end{pmatrix}$
\end{minipage}
\ \ 
 \begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
-1 & -1 & -1 \\
0 & 0 & 0  \\
1 & 1 & 1 \\
\end{pmatrix}$
\end{minipage}
\end{center}

\subsubsection{Operador de Sobel}

Matrices de Sobel en $x$ e $y$

\begin{center}
\begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1 \\
\end{pmatrix}$
\end{minipage}
\ \ 
 \begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
-1 & -2 & -1 \\
0 & 0 & 0  \\
1 & 2 & 1 \\
\end{pmatrix}$
\end{minipage}
\end{center}

\subsubsection{Operador de Frei-Chen}

Frei-Chen en $x$ e $y$.

\begin{center}
\begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
-1 & 0 & 1 \\
-\sqrt{2} & 0 & \sqrt{2} \\
-1 & 0 & 1 \\
\end{pmatrix}$
\end{minipage}
\ \ 
 \begin{minipage}{0.30 \textwidth}
$\begin{pmatrix}
-1 & -\sqrt{2} & -1 \\
0 & 0 & 0  \\
1 & \sqrt{2} & 1 \\
\end{pmatrix}$
\end{minipage}
\end{center}